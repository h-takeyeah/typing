# **ディレクトリ戦略とクリーンアーキテクチャの実践**
本ドキュメントでは、このプロジェクトのディレクトリ構造を詳細に説明し、クリーンアーキテクチャをどのように適用しているのかを体系的に解説します。

---

## **ディレクトリ構造の概要**
本プロジェクトは、**Go 言語のクリーンアーキテクチャに基づいた WebAPI サーバー** です。
以下のディレクトリ構成を採用し、それぞれの役割を明確に分離しています。

```
.
├── Dockerfile                # 本番環境向けの Docker コンテナ設定
├── Dockerfile.dev            # 開発環境向けの Docker コンテナ設定
├── cmd                       # アプリケーションのエントリーポイント
│   └── server
│       └── main.go           # メインエントリーポイント
├── config                    # 設定管理
│   └── config.go             # 設定ファイルのロード処理
├── docker-compose.dev.yml    # 開発環境用 Docker Compose 設定
├── docker-compose.yml        # 本番環境用 Docker Compose 設定
├── docs                      # ドキュメント
│   ├── about-openapi.md      # OpenAPI に関するドキュメント
│   └── directory-strategy.md # ディレクトリ戦略（本ドキュメント）
├── go.mod                    # Go モジュール管理
├── go.sum                    # 依存関係のチェックサム
├── internal                  # アプリケーションの内部実装（外部公開しない）
│   ├── domain                # ドメイン層（ビジネスロジック）
│   │   ├── model             # エンティティ（ドメインモデル）
│   │   │   └── model.go
│   │   ├── repository        # データアクセスのインターフェース
│   │   │   ├── score_repository.go
│   │   │   ├── tx_manager.go
│   │   │   └── user_repository.go
│   │   ├── service           # ビジネスロジックを適用するサービス層
│   │   │   └── score_service.go
│   │   └── usecase           # ユースケース層（アプリケーションの振る舞い）
│   │       ├── score_usecase.go
│   │       └── user_usecase.go
│   ├── infra                 # インフラストラクチャ層（外部との接続）
│   │   └── ent               # ent（ORM）の設定・リポジトリ実装
│   │       └── repository
│   │           ├── ent_score_repository.go
│   │           ├── ent_tx_manager.go
│   │           └── ent_user_repository.go
│   └── interfaces            # インターフェースアダプタ層（API やルーティング）
│       ├── handler           # HTTP ハンドラ（API エンドポイント）
│       │   ├── healthcheck_handler.go
│       │   ├── score_handler.go
│       │   └── user_handler.go
│       └── router.go         # ルーティング設定
├── openapi.yaml              # OpenAPI スキーマ定義
└── pkg                       # 外部でも利用可能なパッケージ
    ├── logger                # ロギング機能
    │   └── logger.go
    └── middleware            # ミドルウェア
        ├── cors.go           # CORS 設定
        └── trace.go          # トレースログ設定
```
---

# **ディレクトリ戦略とクリーンアーキテクチャに関するQ&A**
本ドキュメントでは、クリーンアーキテクチャの概念やディレクトリ戦略に関する疑問を **Q&A 形式** で解説します。
プログラミング初心者が理解しやすいよう、 **抽象化、依存関係、トランザクション管理** などの基本概念についても触れています。

---

## **1. クリーンアーキテクチャとは何ですか？**
### **Q:** クリーンアーキテクチャとは何ですか？なぜ必要なのですか？
**A:** クリーンアーキテクチャとは、**「アプリケーションのビジネスロジックを保護し、変更に強いシステムを構築するための設計パターン」** です。
主な目的は **「関心の分離 (Separation of Concerns)」** にあります。

例えば、次のようなメリットがあります：
1. **ビジネスロジックを外部の影響から守る**（データベースやフレームワークの変更に強い）
2. **コードの保守性が高くなる**（変更が局所的になり、大規模開発でも壊れにくい）
3. **テストが容易になる**（ビジネスロジックとインフラを分離するため、モックを活用しやすい）

---

### **Q:** クリーンアーキテクチャはどのような層で構成されていますか？
**A:** 本プロジェクトでは、以下の 4 層に分割しています。

| レイヤー               | 役割 |
|------------------------|------|
| **エンティティ層（Entities）** | 変更されない純粋なビジネスルール（ドメインモデル） |
| **ユースケース層（UseCase）** | アプリケーションの振る舞いを定義 |
| **インターフェース層（Interfaces）** | API、DB、UI などの外部インターフェースとの接続 |
| **インフラ層（Infrastructure）** | データベース、ログ、ミドルウェアなどの外部サービスとのやり取り |

---

## **2. 抽象化と依存関係**
### **Q:** 依存関係を逆転させるとはどういうことですか？
**A:** 依存関係の逆転（Dependency Inversion）とは、**「ビジネスロジックがインフラに依存するのではなく、インターフェースを通じて依存するようにする」** ことです。

例えば、`usecase` が直接 `ent.Client` に依存すると、`ent` を変更したときに `usecase` まで修正が必要になります。
そこで、`repository` インターフェースを定義し、`usecase` はインターフェースを通じてデータを取得するようにします。

```go
// インターフェースを定義（usecase はこれに依存する）
type UserRepository interface {
    GetUserByStudentNumber(ctx context.Context, studentNumber string) (*model.User, error)
}
```

この設計により、データベース (`ent`) を `MongoDB` や `Firestore` に変更しても、`usecase` を変更せずに済みます。

---

### **Q:** なぜ `usecase` に `TxManager` を渡すのですか？
**A:** `repository` の中でトランザクション (`tx.Commit() / tx.Rollback()`) を管理すると、複数の `repository` を組み合わせた操作が難しくなります。
そのため、`TxManager` という **トランザクションを管理するインターフェース** を作り、`usecase` で制御できるようにします。

---

## **3. ディレクトリ戦略**
### **Q:** `internal` にすべてのコードを入れるのはなぜですか？
**A:** `internal/` は Go の標準的なディレクトリで、**外部パッケージからのアクセスを防ぐため** にあります。
これにより、`internal` 以下のコードは、他の Go プロジェクトから直接 import できなくなり、内部実装を隠蔽できます。

---

### **Q:** `pkg/` には何を入れるべきですか？
**A:** `pkg/` には、**外部プロジェクトでも再利用可能なコード** を入れます。
例えば、`logger` や `middleware` は `pkg/` に配置し、他のプロジェクトでも使える形にします。

- **入れるべきもの:** ロガー、ミドルウェア、汎用ユーティリティ
- **入れるべきでないもの:** `usecase` や `repository`（アプリケーション固有のもの）

---

## **4. 具体的な実装の考え方**
### **Q:** `handler` の役割は何ですか？
**A:** `handler` は、HTTP リクエストと `usecase` の橋渡しをする役割です。

1. **リクエストのバリデーションを行う**
2. **`usecase` にデータを渡して処理を実行**
3. **レスポンスを適切な HTTP ステータスコードで返す**

---

### **Q:** `repository` はデータの取得・保存だけをするべきですか？
**A:** **はい。ビジネスロジックは持つべきではありません。**
`repository` は、**データの CRUD を提供することに専念するべき** です。

---

## **5. クリーンアーキテクチャのメリット**
### **Q:** この設計にすることで何が得られますか？
1. **データベースや外部 API の変更に強い**
2. **ビジネスロジックが一箇所にまとまり、バグが少なくなる**
3. **テストがしやすくなる（モックを使って `usecase` を単体テストできる）**
